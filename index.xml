<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>阿兵云原生</title>
    <link>https://qingconglaixueit.github.io/</link>
    <description>Recent content on 阿兵云原生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Apr 2023 11:16:30 +0800</lastBuildDate><atom:link href="https://qingconglaixueit.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>何必去卷 AI，对于普通人简单好用的智能软件推荐</title>
      <link>https://qingconglaixueit.github.io/post/%E4%BD%95%E5%BF%85%E5%8E%BB%E5%8D%B7-ai%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E4%BA%BA%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%902/</link>
      <pubDate>Wed, 26 Apr 2023 11:16:30 +0800</pubDate>
      
      <guid>https://qingconglaixueit.github.io/post/%E4%BD%95%E5%BF%85%E5%8E%BB%E5%8D%B7-ai%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E4%BA%BA%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%902/</guid>
      <description>一天，小明要写一篇论文，但是他遇到了一个问题：他期望有这么一个软件可以智能精准回复，能进行训练，还能帮忙处理数据。于是他开始寻找解决方案。
可以使用最近很火很卷的 chatgpt 呀，于是简单搜索并了解了一下 什么是 chatgpt
什么是 chatgpt Chatgpt 是一种基于自然语言处理技术的智能聊天系统。它可以自动理解用户输入的文本，并作出相应的回应，从而与用户进行实时的对话。
Chatgpt 通常使用机器学习和深度学习算法来训练它的模型，以便更好地理解和响应用户的输入。它还具有自我学习和适应性能力，因此可以根据与用户的交互不断改进和优化其性能。
Chatgpt 已经被广泛应用于各个领域，例如客服、营销、教育等。它可以有效地提高服务质量、节省时间成本，并提高用户满意度。
ChatGPT 于 2022 年 11 月推出，尽管其回答事实的准确性受到批评，但因其详细和清晰的回复而受到关注。
再继续搜索，看到网上的注册和使用教程铺天盖地，自己看的眼花缭乱，小明随机选了一个教程进行学习和尝试，然而跟着教程来发现自己需要达到教程上的效果差距还很明显
例如需要不一样的网络，需要购买 openai 的账号，为了能够更好的服务小明，还要考虑去买更加智能的 chatgpt 4
折腾了一圈，发现自己时间，精力消耗了不少，花了不少钱，然而并没有达到自己期望的结果，那就是期望有软件来帮助自己，解决自己的一些问题，数据处理，资料查找等。
其实我们身边有很多这样的朋友，花了钱，花了精力，自己没有折腾出个所以然，实际上自己的需求其实很简单，就是能够方便的用上 chatgpt 的能力，自己还不用管软件的部署环境，软件的账号是否可以使用的问题
并且我们身边的朋友还遇到了这样的问题，买了账号之后，发现自己使用不规范，自己的账号被封了，没有办法使用调用 api 的方式来享受 chatgpt 的能力
那么是否可以有这样一个软件就像手机里面的 app，或者小程序一样呢？直接在海内的环境中就可以直接简单便捷的去寻找我们期望的答案，如同身边有一个小助手一样，帮我们处理数据，回答我们的问题
对于程序员，可以问他关于编程方面的书籍推荐，进阶路线，实际问题解决方案，代码编写，甚至是代码纠错也是非常 nice 的
对于白领，可以问他关于时间管理，资料整理，人际交往，个人成长 等等问题，他也能像人一样给予你很好的指导
对于学生，你可以问他关于学科资料，解题方案，具体的论点数据等，不用上到某些搜索引擎上搜索半天还看了一堆的广告好太多了
对于宝妈， 自然也是完全 ok 的，你可以了解关于育儿的技巧，关于如何处理好亲密关系，如何引导孩子健康成长
只要你有向外的需求，你就可以使用这个软件，为你提升效率，提升质量，节省出来的时间，你能去做更多有价值有意义的事情
那么他是谁呢？
他就是 Ai 助手
南羽云Ai助手 使用 南羽云 Ai 助手 你可以无需考虑自己部署环境，购买 openai 账号，甚至都不需要去关心你的网络是否特殊的问题
首先，它的推荐非常准确，让你省去了大量的时间和精力去搜索和比较各种软件；
其次，它还提供了各种实用的功能和工具，让你的研究更加高效和便捷。
除此之外，南羽云 Ai 助手 还有一个非常重要的特点：它可以不断学习和进化，以满足不同用户的需求和挑战，甚至你还可以训练他
相信这个软件将会成为你未来的得力助手，帮助你更好地完成各种任务和项目。
充电计划 软件开发不易，大家可以放心购买和使用我们的软件，我们长期维护，提供技术支持，放心使用
如果你期望自己去做定制化开发，也是完全没有问题的，这里我们开源了前端代码</description>
    </item>
    
    <item>
      <title>缓存的设计方式</title>
      <link>https://qingconglaixueit.github.io/post/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 17 Jul 2022 12:09:06 +0800</pubDate>
      
      <guid>https://qingconglaixueit.github.io/post/%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F/</guid>
      <description>问题情况： 当有大量的请求到内部系统时，若每一个请求都需要我们操作数据库，例如查询操作，那么对于那种数据基本不怎么变动的数据来说，每一次都去数据库里面查询，是很消耗我们的性能
尤其是对于在海量数据中进行数据操作的时候，如果都是从 DB 中进行加载，那这是在挑战用户的耐性
简单来看，例如我们要去小区里面了解一个人在不在家，当没有通讯工具的前提下，我们每一次都要经过小区们的保安，然后再到具体的单元楼，最终到了这家门口，最终才知道在不在家
如果我们换了一个比较优秀的保安，他知道当前小区里面的特定的家里面是否有人，那这个时候，如果我们直接去问小区保安，自然就无需跑冤枉路了，自然就提高了效率
此处简单的就可以将优秀保安看做是一个缓存，我们每一次去访问，就会先去访问缓存 ， 这样就能极大的提高访问效率和系统性能
可以看出，有一个优秀的保安相当重要
缓存的基本设计方式是什么样的 设计缓存自然也是为了解决系统是的低效问题，让系统可以高性能，高并发
例如我们直接访问单机的数据库如mysql 也就是上千级别的 qps，如果是访问 缓存的时候，就能达到上万，上十几万，这差距不是一点半点，是一个质的飞越
缓存的设计实际上就是 DB 和 缓存操作顺序以及谁来操作的事情，大体分为如下 4 种模式
Cache Aside Read Through Write Through Write Behind Caching 上述四种模式， Cache Aside 用的方式是最常使用的，咱们后续细说
后续三种模式的含义是
Read Through
是在查询操作的时候更新缓存，若缓存失效了，则是由缓存服务器自己将数据加载到缓存中 Write Through
是在更新数据库的时候，如果命中了缓存，则先更新缓存，再由缓存服务器自己去更新数据， 如果是没有命中缓存，那么就直接更新数据库 Write Behind Caching 通过名字我们知道，是在写到缓存操作之后才做些操作，实际上这种模式只更新缓存，不会更新数据库，缓存服务器会以异步的方式将数据批量更新到数据库中
很明显，这种，模式速度自然会更快，可这种模式对于保证数据库和缓存数据一致性问题，是个硬伤，且还会存在丢数据的情况，比如，咱们的缓存服务器挂掉了
Cache Aside 读写缓存模式是怎么玩的 Cache Aside 读写模式缓存又是如何去处理的呢，一起来看看
Cache Aside 模式读取数据的逻辑是这个样子的：
读取数据时
先读取缓存中的数据，如果缓存中有数据，则直接返回 若缓存中没有数据，则去读数据库中的数据，并将数据同步到缓存中 写入数据时
写入数据库，写入成功时，将缓存的数据删除掉 仔细的同学可能会思考并提出这样的问题，如果我一个查询操作，现在缓存中无数据，此时会去数据库中查询，在这个过程中，另外有一个写入数据库的操作，且操作完毕后，删除了缓存，这个时候，第一个操作实际上从数据库拿到的还是之前的老数据，并且会将数据放到缓存中，那么此时的数据实际上是一个老数据，也可以理解是在脏数据
这个点其实我们就无需担心了，大佬们已经论证过这种情况出现的概率极低
因为咱们的写表操作是要锁表的，且我们知道数据库写入操作比读取操作要慢，也就是说，当同时有一个读取和写入 DB 的操作时，自然是写入的操作是要后返回结果的，此处不要杠啥读写数据量不一致的情况，咱们做对比，自然是在同等条件下比较咯
从图中我们知道，同等条件下，先进行查询 DB 的操作，过程中，来了一个写入 DB 操作，自然是 查询操作先返回，写入操作再返回结果</description>
    </item>
    
    <item>
      <title>谈谈对GMP的简单认识</title>
      <link>https://qingconglaixueit.github.io/post/%E8%B0%88%E8%B0%88%E5%AF%B9gmp%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Sun, 17 Jul 2022 12:08:00 +0800</pubDate>
      
      <guid>https://qingconglaixueit.github.io/post/%E8%B0%88%E8%B0%88%E5%AF%B9gmp%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/</guid>
      <description>犹记得最开始学习 golang 的时候，大佬们分享 GMP 模型的时候，总感觉云里雾里，听了半天，并没有一个很清晰的概念，不知 xmd 是否会有这样的体会
虽然 golang 入门很简单，但是对于理解 golang 的设计思想和原理，还是需要一定时间的积累和沉淀，更多的应该是思想上的沉淀
希望这篇文章能够对你了解 golang 的 GMP 模型有一点帮助
文章分别从一下三个方面来谈谈我对 GMP 模型认识
golang 中调度器的变化及其作用 有了进程，线程，为什么会出现协程 GMP 模型中的 G,M,P 分别都做着什么样的事情 golang 中的调度器的变化及其作用 调度器，scheduler
怎么理解呢？调度器就像是一个管理者，负责安排事项，负责调度不同人在指定时间在某个岗位上完成自己的价值交付
正如 linux 调度器一样，将就绪的进程调度成执行状态，或者将执行状态的进程，打断，变成阻塞状态，再变成就绪状态
比如说一个经典的单进程 和 多进程/多线程的操作系统，
我们可以看到在单进程系统中，只需要无脑的将进程串行排列好， CPU 会串行去执行任务，如果遇到进程1 阻塞的情况，其他进程也没有办法被 cpu 执行，那么进程2 ，进程3 ，进程4 就都要等待前面的进程完成执行完毕，才能到自己执行
可以看出单进程对于 CPU 的使用过于任性，浪费 CPU 的资源，演进到多进程/多线程操作系统的时候，就出现了调度器
上图中我们可以对比看到，在多进程/多线程的操作系统中，cpu 的时间片被分割的更加的小，对于 cpu 资源的利用率是大大的增加了，因为 cpu 可以在进程1阻塞的时候，切换去执行进程2
例如，当进程1 执行过程中，发生了阻塞，那么调度器就会就会将 cpu 切换到进程2 中进行执行，同理，进程2 阻塞的时候， cpu 就会被切换到进程 3 进行执行，当然，这就看是哪个进程先抢到 cpu 资源了
可以看到，调度器在这里的作用就是最大限度的利用上 CPU 的资源，管理进程在 CPU 上按照一定的的顺序执行任务，就好比一个优秀的管家可以合理安排好不同的员工在指定的时间上专注的处理某项事务</description>
    </item>
    
    <item>
      <title>GRPC客户端需要连接池吗</title>
      <link>https://qingconglaixueit.github.io/post/grpc%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%90%97/</link>
      <pubDate>Sun, 17 Jul 2022 12:06:00 +0800</pubDate>
      
      <guid>https://qingconglaixueit.github.io/post/grpc%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%90%97/</guid>
      <description>发现的问题 在微服务开发中，gRPC 的应用绝对少不了，一般情况下，内部微服务交互，通常是使用 RPC 进行通信，如果是外部通信的话，会提供 https 接口文档
对于 gRPC 的基本使用可以查看文章 gRPC介绍
对于 gRPC ，我们需要基本知道如下的一些知识点：
gRPC 的基本四种模式的应用场景
请求响应模式 客户端数据流模式 服务端数据流模式 双向流模式 Proto 文件的定义和使用 gRPC 拦截器的应用 ， 基本的可以查看这篇 gRPC 拦截器
实际上有客户端拦截器 和 服务端拦截器，具体详细的可以自行学习 gRPC 的设计原理细节 Go-Kit 的使用 当然今天并不是要聊 gRPC 的应用或者原理，而是想聊我们在开发过程中很容易遇到的问题：
未复用 gRPC 客户端连接，影响性能 最近审查各个服务代码中，发现整个部门使用 gRPC 客户端请求服务端接口的时候，都是会新建一个连接，然后调用服务端接口，使用完毕之后就 close 掉， 例如这样
这会有什么问题呢？
正常简单的使用不会有啥问题，但如果是面临高并发的情况，性能问题很容易就会出现，例如我们在做性能测试的时候，就会发现，打一会性能测试，客户端请求服务端的时候就会报错：
rpc error: code = Unavailable desc = all SubConns are in TransientFailure, latest connection error: connection error: desc = &amp;quot;transport: Error while dialing dial tcp xxx:xxx: connect: connection refused</description>
    </item>
    
    <item>
      <title>Redis中sds数据结构和底层设计原理</title>
      <link>https://qingconglaixueit.github.io/post/redis%E4%B8%ADsds%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 08 Jul 2022 21:55:47 +0800</pubDate>
      
      <guid>https://qingconglaixueit.github.io/post/redis%E4%B8%ADsds%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</guid>
      <description>redis 是 C 语言写的，那么我们思考一下 redis 是如何表示一个字符串的？redis 的数据结构和 C 语言的数据结构是一样的吗？
我们可以看到 redis 源码中的 sds 库函数，和 sds 的具体实现，分别有如下 2 个文件：
sds.h sds.c 具体路径是：deps/hiredis/sds.h , deps/hiredis/sds.c
sds.h 中涉及如下数据结构：
SDS redis 中 SDS simple Dynamic string
简单动态字符串
C 语言中表示字符串的方式是字符数组，例如：
char data[]=&amp;#34;xiaomotong&amp;#34; 如果 C 语言需要扩容的话需要重新分配一个再大一点的内存，存放新的字符串，若每次都要重新分配字符串，对于效率和性能必然会大大降低，并且若某一个字符串是 “xiaomo\0tong”
这个时候，实际上 C 中 遇到 ‘\0’ 就结束了，因此实际 “xiaomo\0tong” 只会读取到xiaomo ,字符串长度就是 6
因此 redis 中的 sds 数据结构是这样设计的，是通过一个成员来标志字符串的长度：
SDS： free:0 len:6 char buf[]=&amp;#34;xiaomo&amp;#34; 若这个时候，我们需要在字符串后面追加字符串， sds 就会进行扩容，例如在后面加上 “tong” ， 那么 sds 的数据结构中的值会变成如下： free:10 len:10 char buf[]=&amp;#34;xiaomotong&amp;#34; 最后的 &amp;quot;xiaomotong&amp;quot; 也是带有\0的，这也保持了 C 语言的标准，redis 中对于 sds 数据结构扩容是成倍增加的，但是到了一定的级别，例如 1M 的时候，就不会翻倍的扩容，而是做加法 例如 1M 变成 2M ， 2M 变成 3M 等等</description>
    </item>
    
    <item>
      <title>2022-07-03 年中简述</title>
      <link>https://qingconglaixueit.github.io/post/hello/</link>
      <pubDate>Fri, 08 Jul 2022 21:40:19 +0800</pubDate>
      
      <guid>https://qingconglaixueit.github.io/post/hello/</guid>
      <description>练习引体向上的少年的2022年中总结 对于年中或者年度总结不知多少小伙伴是自己选择来进行一次总结还是基于其他的原因，无论如何，既然做了，就好好分析一下。
这半年来，我是读书，写作，刷题，做饭，健身，工作样样都干，就是没有干点跳槽的事情， 对于干的每一件事情或多或少都有点自己的想法，那就来吧
先来简单看看目标完成情况 继续云原生方向发力，深耕云原生方向 40% 技术驱动团队，引入新框架 40% 熟悉业内认证领域做法 40% 健身练出 8 块腹肌 50% 想问问这个百分比是如何敲定出来的？ 实际上并没有什么数据支撑，完全是凭感觉，所以接下来制定的下半年的目标会进行调整，需要用数据做支撑，清晰可达成
不过对于健身来说， 8 块腹肌，完成了 50 % ，这个还是有数据支撑的，因为可以看到有 4 块了 😂
过完春节便开始一如往常回到办公地进行打工人的生活，今年或许和往年不太一样
今年换了一个宽大一点的房间，买了室内健身架，本以为自己会持续锻炼一下，可是没想到，还真的就保持了锻炼的习惯😎
微健身 半年进行的健身，从内脏脂肪 7.5 到现在 5.0，从游泳圈到现在差点可以看到腹斜肌 👀
从 2 月 9 日开始，便开始每周三到四次的锻炼，甚至开始早晨起来锻炼 10 分钟，目的是为了唤醒自己的身体，还在门背后记录打卡情况
起初，还能坚持做到每周目标的次数，每次早晨起来就会做关于腹部的简单训练，为什么会是腹部呢？
相信咱们做挨踢的，很多人是瘦瘦的，但是肚子大大滴，不仅影响形象，还影响健康
一次，健身有点猛，做了引体，做了腹肌，还去做有氧操，健身后未注意保暖，导致着凉，体内侵入风寒，接下来的一周，感觉整个人都要死了，毫无生气，每天都拖着沉重的身体，坚持上班🤦‍♂️
好在，这周没有作死😃，当身体疲惫的时候，千万不要锻炼身体，健身，实际上是在伤身，如果身体没有得到充分的休息和营养，那么得不偿失，尤其是这半年，看到一些大厂员工在疲劳的时候去健身出现了各种事故的，心里一咯噔
值得一提的是，这半年我没有刻意练习胸肌，而是在刻意练习引体向上
从刚开始的练习 K1 KEEP 到 现在 K4 ， 有了一个明显的提升。简单来说，刚开始练习引体向上的时候，发现会消耗很多精力在握杠上面，很多人刚开始是握不住单杠的，更别说拉起自己了，那是相当费劲
坚持每周三练，每一次按照 keep 训练的来，关注自身每一次做的动作是否标准，做的动作到哪个节点的时候，开始出现自身力竭，便会关注这些数据，到下一次练习的时候，刻意突破，不过确实有效果
我劝 xdm 不要练习引体向上，因为，练了之后，你的衣服会变小，你的肩膀会变宽，肩部的肌肉会慢慢引起你的注意👀
读书，刷题，做项目 H1 本来是一个不是很忙的阶段，可是万万没想到，在今年连深圳都出现封城的情况，我们的销售还能喜报连连
每接到一个项目之初，同时也得到了一个交付的承诺时间， what？？？ 交付时间完全由销售定？？
所以这半年来基本都是在啃次啃次的设计和落地每一个项目
这也影响了自己在文章方面的输出，基本全是刷题 ， 不过刷题也让我回顾了一些以前写过但并没有完全理解的题和知识点</description>
    </item>
    
  </channel>
</rss>
